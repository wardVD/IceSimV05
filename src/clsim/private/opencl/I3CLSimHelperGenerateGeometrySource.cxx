/**
 * Copyright (c) 2011, 2012
 * Claudio Kopper <claudio.kopper@icecube.wisc.edu>
 * and the IceCube Collaboration <http://www.icecube.wisc.edu>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *
 *
 * $Id: I3CLSimHelperGenerateGeometrySource.cxx 130806 2015-03-31 03:12:34Z nega $
 *
 * @file I3CLSimStepToPhotonConverterOpenCL.cxx
 * @version $Revision: 130806 $
 * @date $Date: 2015-03-30 22:12:34 -0500 (Mon, 30 Mar 2015) $
 * @author Claudio Kopper
 */

#include "opencl/I3CLSimHelperGenerateGeometrySource.h"

#include <string>
#include <sstream>
#include <stdexcept>

#include <vector>
#include <cmath>
#include <set>

#include "dataclasses/I3Constants.h"

#include <boost/lexical_cast.hpp>
#include <boost/foreach.hpp>

#define __CL_ENABLE_EXCEPTIONS
#include "clsim/cl.hpp"

#include "clsim/I3CLSimHelperToFloatString.h"


namespace I3CLSimHelper
{
    
    // forward
    bool write_geometry_code_and_fill_buffer(std::string &code, 
                                             const std::vector<int> &stringIDs,
                                             const std::vector<unsigned int> &domIDs,
                                             const std::vector<double> &posX,
                                             const std::vector<double> &posY,
                                             const std::vector<double> &posZ,
                                             const std::vector<std::string> &subdetectors,
                                             const double omRadius,
                                             std::vector<cl_ushort> &geoLayerToOMNumIndexPerStringSetBuffer,
                                             std::vector<int> &stringIndexToStringIDBuffer,
                                             std::vector<std::vector<unsigned int> > &domIndexToDomIDBuffer_perStringIndex
                                             );
    
    // the main converter
    std::string GenerateGeometrySource(const I3CLSimSimpleGeometry &geometry,
                                       std::vector<unsigned short> &geoLayerToOMNumIndexPerStringSetBuffer,
                                       std::vector<int> &stringIndexToStringIDBuffer,
                                       std::vector<std::vector<unsigned int> > &domIndexToDomIDBuffer_perStringIndex)
    {
        geoLayerToOMNumIndexPerStringSetBuffer.clear();
        stringIndexToStringIDBuffer.clear();
        domIndexToDomIDBuffer_perStringIndex.clear();
        
        std::ostringstream code;
        
        code << "\n";
        code << "///////////////// BEGIN ice/water properties ////////////\n";
        code << "\n";

        code << "// ice/water properties, auto-generated by\n";
        code << "// I3CLSimHelper::GenerateGeometrySource()\n";
        code << "\n";

        {
            std::string geo_code;
            bool ret = 
            write_geometry_code_and_fill_buffer(geo_code, 
                                                geometry.GetStringIDVector(),
                                                geometry.GetDomIDVector(),
                                                geometry.GetPosXVector(),
                                                geometry.GetPosYVector(),
                                                geometry.GetPosZVector(),
                                                geometry.GetSubdetectorVector(),
                                                geometry.GetOMRadius(),
                                                geoLayerToOMNumIndexPerStringSetBuffer,
                                                stringIndexToStringIDBuffer,
                                                domIndexToDomIDBuffer_perStringIndex
                                                );
            
            if (!ret)
                throw std::runtime_error("Could not use this geometry for OpenCL.");
            
            code << geo_code;
        }        
        
        code << "\n";
        code << "///////////////// END ice/water properties ////////////\n";
        code << "\n";

        
        return code.str();
    }
    

    
    /////////// HELPERS
    
    struct domStruct {
        unsigned int domID;
        double posX, posY, posZ;
    };
    
    struct stringStruct {
        int stringID;
        double meanX;
        double meanY;
        double maxZ, minZ;
        double meandZ;
        double maxR;
        std::vector<domStruct> doms;
        unsigned short subdetectorNum;
    };
    
    bool divideIntoCells(const std::vector<stringStruct> &strings,
                         int subdetectorNum,
                         double &cellStartX,
                         double &cellStartY,
                         double &cellWidthX,
                         double &cellWidthY,
                         unsigned int cellNumX,
                         unsigned int cellNumY,
                         std::vector<unsigned short> &cellToStringIndex)
    {
        if ((cellNumX==0) || (cellNumY==0)) {log_fatal("cell count is zero");}
        if (strings.size()<=0) {log_fatal("no strings found");}
        
        log_trace("New division try: cellNumX=%u cellNumY=%u", cellNumX, cellNumY);
        
        cellToStringIndex.resize(cellNumX*cellNumY);
        
        // find minimum x and y detector coordinates
        std::size_t numberOfStrings=0;
        double minX=NAN, minY=NAN, maxX=NAN, maxY=NAN;
        BOOST_FOREACH(const stringStruct &currentString, strings)
        {
            if (subdetectorNum >= 0) {
                if (currentString.subdetectorNum != static_cast<unsigned short>(subdetectorNum)) continue;
            }
            
            ++numberOfStrings;
            
            if ((currentString.meanX-currentString.maxR < minX) || std::isnan(minX)) {
                minX = currentString.meanX-currentString.maxR;
            }
            if ((currentString.meanY-currentString.maxR < minY) || std::isnan(minY)) {
                minY = currentString.meanY-currentString.maxR;
            }
            if ((currentString.meanX+currentString.maxR > maxX) || std::isnan(maxX)) {
                maxX = currentString.meanX+currentString.maxR;
            }
            if ((currentString.meanY+currentString.maxR > maxY) || std::isnan(maxY)) {
                maxY = currentString.meanY+currentString.maxR;
            }
        }
        if (numberOfStrings<=0) {log_fatal("no strings found");}

        // calculate cell widths
        cellStartX=minX;
        cellStartY=minY;
        cellWidthX=(maxX-minX)/static_cast<double>(cellNumX);
        cellWidthY=(maxY-minY)/static_cast<double>(cellNumY);
        
        std::set<unsigned short> assignedStringNums;
        
        //unsigned int numAssignedStrings=0;
        
        for (unsigned int i=0;i<cellNumX;++i)
        {
            for (unsigned int j=0;j<cellNumY;++j)
            {
                const double cellXMin = cellStartX+static_cast<double>(i)*cellWidthX;
                const double cellXMax = cellStartX+static_cast<double>(i+1)*cellWidthX;
                const double cellYMin = cellStartY+static_cast<double>(j)*cellWidthY;
                const double cellYMax = cellStartY+static_cast<double>(j+1)*cellWidthY;
                
                bool stringFound=false;
                unsigned long stringFoundNum=0xFFFF;
                // we got a cell, now loop over all strings to find if any one is in here
                
                for (unsigned long thisString=0;thisString<strings.size();++thisString)
                {
                    const stringStruct &currentString = strings[thisString];
                    
                    if (subdetectorNum >= 0) {
                        if (currentString.subdetectorNum != static_cast<unsigned short>(subdetectorNum)) continue;
                    }

                    bool cellContainsStringX=false;
                    bool cellContainsStringY=false;
                    
                    if ((currentString.meanX-currentString.maxR <= cellXMin) &&
                        (currentString.meanX+currentString.maxR >= cellXMin))
                        cellContainsStringX=true;
                    if ((currentString.meanX-currentString.maxR <= cellXMax) &&
                        (currentString.meanX+currentString.maxR >= cellXMax))
                        cellContainsStringX=true;
                    if ((currentString.meanX-currentString.maxR >= cellXMin) &&
                        (currentString.meanX+currentString.maxR <= cellXMax))
                        cellContainsStringX=true;
                    if ((currentString.meanY-currentString.maxR <= cellYMin) &&
                        (currentString.meanY+currentString.maxR >= cellYMin))
                        cellContainsStringY=true;
                    if ((currentString.meanY-currentString.maxR <= cellYMax) &&
                        (currentString.meanY+currentString.maxR >= cellYMax))
                        cellContainsStringY=true;
                    if ((currentString.meanY-currentString.maxR >= cellYMin) &&
                        (currentString.meanY+currentString.maxR <= cellYMax))
                        cellContainsStringY=true;
                    
                    if ((cellContainsStringX) && (cellContainsStringY))
                    {
                        if (stringFound) 
                        {
                            log_trace("Segmentation is not valid, string %lu and %lu are in the same cell.",
                                      thisString, stringFoundNum);
                            log_trace("  -> string %lu reaches from x=[%f,%f], y=[%f,%f]",
                                      thisString,
                                      currentString.meanX-currentString.maxR, currentString.meanX+currentString.maxR,
                                      currentString.meanY-currentString.maxR, currentString.meanY+currentString.maxR);
                            log_trace("  -> string %lu reaches from x=[%f,%f], y=[%f,%f]",
                                      stringFoundNum,
                                      strings[stringFoundNum].meanX-strings[stringFoundNum].maxR, strings[stringFoundNum].meanX+strings[stringFoundNum].maxR,
                                      strings[stringFoundNum].meanY-strings[stringFoundNum].maxR, strings[stringFoundNum].meanY+strings[stringFoundNum].maxR);
                            return false; // two strings per cell -> fail!
                        }
                        stringFound=true;
                        stringFoundNum=thisString;
                        assignedStringNums.insert(thisString);
                        //++numAssignedStrings;
                    }
                } //for(string)
                
                if (stringFound) {
                    cellToStringIndex[j*cellNumX+i] = stringFoundNum;
                } else {
                    cellToStringIndex[j*cellNumX+i] = 0xFFFF;
                }
                
                
            } // for(j)
        } // for(i)
        
        
        if (assignedStringNums.size()!=numberOfStrings) {
            std::cerr << "Internal error in cell division algorithm." << std::endl;
        }
        
        return true;
        
    }
    
    bool doesMatchLayering(const stringStruct &currentString,
                           double layerStartZ,
                           double layerHeight,
                           unsigned int layerNum,
                           const double domRadius,
                           const std::vector<unsigned short> &layerToOMNumIndex)
    {
        if (layerNum==0) return false;
        if (domRadius < 0.) return false;
        if (currentString.doms.size() >= 0xFFFF) {
            log_fatal("Dom numbers >= 65535 are not supported!");
        }
        if (layerToOMNumIndex.size() != layerNum) {
            log_fatal("Internal error: layerToOMNumIndex.size() != layerNum");
        }
        
        std::size_t domsAssigned=0;
        
        for (unsigned int i=0;i<layerNum;++i)
        {
            const double layerZMin = layerStartZ+static_cast<double>(i)*layerHeight;
            const double layerZMax = layerStartZ+static_cast<double>(i+1)*layerHeight;
            
            unsigned short layerShouldContainDom=0xFFFF;
            
            for (unsigned long thisDom=0;thisDom<currentString.doms.size();++thisDom)
            {
                const domStruct &currentDom = currentString.doms[thisDom];
                double domZ = currentDom.posZ;
                
                bool layerContainsDom=false;
                
                if ((domZ-domRadius <= layerZMin) &&
                    (domZ+domRadius >= layerZMin))
                    layerContainsDom=true;
                if ((domZ-domRadius <= layerZMax) &&
                    (domZ+domRadius >= layerZMax))
                    layerContainsDom=true;
                if ((domZ-domRadius >= layerZMin) &&
                    (domZ+domRadius <= layerZMax))
                    layerContainsDom=true;
                
                
                if (layerContainsDom)
                {
                    if (layerShouldContainDom!=0xFFFF) {
                        return false; // two different doms from the same string per layer -> fail!
                    } else {
                        layerShouldContainDom = thisDom;
                        ++domsAssigned;
                    }
                }
                
            } // for(dom)
            
            if (layerToOMNumIndex[i] != layerShouldContainDom) {
                //std::cout << "Layer " << i << " should contain OM " << (int)layerToOMNumIndex[i] << " but contains " << (int)layerShouldContainDom << std::endl;
                return false; // incompatible
            }
            
        } // for (i)
        
        if (domsAssigned != currentString.doms.size())
        {
            //std::cout << "Not all doms assigned to layers. expected " << currentString.doms.size() << ", but got " << domsAssigned << std::endl;
            return false; // not all DOMs in layers
        }
        
        return true; // everything is compatible
    }
    
    void findOverallStringMinMaxZ(const std::vector<stringStruct> &strings,
                                  const double domRadius,
                                  double &minZ,
                                  double &maxZ,
                                  bool includeDomRadius)
    {
        minZ=maxZ=NAN;

        if (includeDomRadius) {
            BOOST_FOREACH(const stringStruct& currentString, strings)
            {
                if ((currentString.minZ-domRadius < minZ) || std::isnan(minZ)) {
                    minZ = currentString.minZ-domRadius;
                }
                if ((currentString.maxZ+domRadius > maxZ) || std::isnan(maxZ)) {
                    maxZ = currentString.maxZ+domRadius;
                }
            }
        } else {
            BOOST_FOREACH(const stringStruct& currentString, strings)
            {
                if ((currentString.minZ < minZ) || std::isnan(minZ)) {
                    minZ = currentString.minZ;
                }
                if ((currentString.maxZ > maxZ) || std::isnan(maxZ)) {
                    maxZ = currentString.maxZ;
                }
            }
        }
    }
    
    bool divideIntoLayers(const stringStruct &currentString,
                          double &layerStartZ,
                          double &layerHeight,
                          unsigned int layerNum,
                          const double domRadius,
                          double minZHint, double maxZHint,
                          std::vector<unsigned short> &layerToOMNumIndex)
    {
        if (layerNum==0) return false;
        if (domRadius < 0.) return false;
        if (currentString.doms.size() >= 0xFFFF) {
            log_fatal("Dom numbers >= 65535 are not supported!");
        }
        
        // set all layers on each string to "no doms inside"
        layerToOMNumIndex.assign(layerNum, 0xFFFF);
        
        // find minimum and maximum z detector coordinates
        double minZ=minZHint, maxZ=maxZHint;
        if ((currentString.minZ-domRadius < minZ) || std::isnan(minZ)) {
            minZ = currentString.minZ-domRadius;
        }
        if ((currentString.maxZ+domRadius > maxZ) || std::isnan(maxZ)) {
            maxZ = currentString.maxZ+domRadius;
        }
        
        // calculate layer heights
        layerStartZ=minZ;
        layerHeight=(maxZ-minZ)/static_cast<double>(layerNum);
        
        for (unsigned int i=0;i<layerNum;++i)
        {
            const double layerZMin = layerStartZ+static_cast<double>(i)*layerHeight;
            const double layerZMax = layerStartZ+static_cast<double>(i+1)*layerHeight;
            
            // we got a layer, now loop over all strings to find if any one is in here
            
            for (unsigned long thisDom=0;thisDom<currentString.doms.size();++thisDom)
            {
                const domStruct &currentDom = currentString.doms[thisDom];
                double domZ = currentDom.posZ;
                
                bool layerContainsDom=false;
                
                if ((domZ-domRadius <= layerZMin) &&
                    (domZ+domRadius >= layerZMin))
                    layerContainsDom=true;
                if ((domZ-domRadius <= layerZMax) &&
                    (domZ+domRadius >= layerZMax))
                    layerContainsDom=true;
                if ((domZ-domRadius >= layerZMin) &&
                    (domZ+domRadius <= layerZMax))
                    layerContainsDom=true;
                
                
                if (layerContainsDom)
                {
                    if (layerToOMNumIndex[i]!=0xFFFF) {
                        //std::cout << "Layer " << i << " should be empty when inserting DOM" << thisDom << ", but contains " << layerToOMNumIndex[i] << std::endl;

                        return false; // two different doms from the same string per layer -> fail!
                    } else {
                        layerToOMNumIndex[i] = thisDom;
                    }
                }
                
            } // for(dom)
            
        } // for(i)
        
        return true;
    }
    
    namespace {
        bool isStringInTemplate(const stringStruct &string,
                                const std::vector<std::vector<double> > &allTemplatePositionsX,
                                const std::vector<std::vector<double> > &allTemplatePositionsY,
                                const std::vector<std::vector<double> > &allTemplatePositionsZ,
                                double offsetX, double offsetY,
                                std::size_t &templateNumber
                                )
        {
            if (allTemplatePositionsX.size() != allTemplatePositionsY.size()) log_fatal("Internal error. template sizes differ x!=y (1)");
            if (allTemplatePositionsX.size() != allTemplatePositionsZ.size()) log_fatal("Internal error. template sizes differ x!=z (1)");
            
            const double epsilon=1e-1*I3Units::mm;
            
            for (std::size_t i=0;i<allTemplatePositionsX.size();++i)
            {
                const std::vector<double> &templateXPositions = allTemplatePositionsX[i];
                const std::vector<double> &templateYPositions = allTemplatePositionsY[i];
                const std::vector<double> &templateZPositions = allTemplatePositionsZ[i];
                if (templateXPositions.size() != templateYPositions.size()) log_fatal("Internal error. template sizes differ x!=y (2)");
                if (templateXPositions.size() != templateZPositions.size()) log_fatal("Internal error. template sizes differ x!=z (2)");

                if (string.doms.size() != templateXPositions.size()) continue; // cannot match
                
                bool match=true;
                for (std::size_t j=0;j<string.doms.size();++j)
                {
                    const domStruct &currentDomStruct = string.doms[j];
                    
                    const double diffX = std::abs(templateXPositions[j]-(currentDomStruct.posX-offsetX));
                    const double diffY = std::abs(templateYPositions[j]-(currentDomStruct.posY-offsetY));
                    const double diffZ = std::abs(templateZPositions[j]-(currentDomStruct.posZ));
                    
                    if (diffX>epsilon) {match=false; break;} // does not match
                    if (diffY>epsilon) {match=false; break;} // does not match
                    if (diffZ>epsilon) {match=false; break;} // does not match
                }
                
                if (match) {
                    // all doms on string match!
                    templateNumber=i;
                    return true;
                }
                
            }

            return false; // no match found
        }
        
    }
    
    std::string generate_get_dom_position_code(const std::vector<stringStruct> &strings)
    {
        std::vector<double> stringMeanPosX(strings.size(), 0.);
        std::vector<double> stringMeanPosY(strings.size(), 0.);
        std::vector<std::size_t> stringMeanPosXYEntries(strings.size(), 0);

        std::size_t maxNumDoms=0;
        for (std::size_t i=0;i<strings.size();++i)
        {
            if (strings[i].doms.size() > maxNumDoms) maxNumDoms=strings[i].doms.size();
            
            for (unsigned long j=0;j<strings[i].doms.size();++j)
            {
                const domStruct &currentDomStruct = strings[i].doms[j];
                
                stringMeanPosXYEntries[i]++;
                stringMeanPosX[i]+=currentDomStruct.posX;
                stringMeanPosY[i]+=currentDomStruct.posY;
            }
        }

        for (std::size_t i=0;i<strings.size();++i)
        {
            stringMeanPosX[i] /= static_cast<double>(stringMeanPosXYEntries[i]);
            stringMeanPosY[i] /= static_cast<double>(stringMeanPosXYEntries[i]);
        }
        
        std::vector<std::size_t> stringInTemplate(strings.size());
        std::vector<std::vector<double> > templatePositionsX;
        std::vector<std::vector<double> > templatePositionsY;
        std::vector<std::vector<double> > templatePositionsZ;
        
        for (std::size_t i=0;i<strings.size();++i)
        {
            const bool stringIsInTemplate = 
            isStringInTemplate(strings[i],
                               templatePositionsX,
                               templatePositionsY,
                               templatePositionsZ,
                               stringMeanPosX[i], stringMeanPosY[i],
                               stringInTemplate[i]);
            
            if (stringIsInTemplate) continue; // nothing else to do, string is now registered in stringInTemplate[i]
            
            // make a new template
            templatePositionsX.push_back(std::vector<double>(strings[i].doms.size(), NAN));
            templatePositionsY.push_back(std::vector<double>(strings[i].doms.size(), NAN));
            templatePositionsZ.push_back(std::vector<double>(strings[i].doms.size(), NAN));
            
            for (unsigned long j=0;j<strings[i].doms.size();++j)
            {
                const domStruct &currentDomStruct = strings[i].doms[j];

                templatePositionsX.back()[j] = currentDomStruct.posX-stringMeanPosX[i];
                templatePositionsY.back()[j] = currentDomStruct.posY-stringMeanPosY[i];
                templatePositionsZ.back()[j] = currentDomStruct.posZ;
                
                stringInTemplate[i] = templatePositionsX.size()-1;
            }
        }
        
        double geoDomPosMaxAbsX_inTemplate=NAN;
        double geoDomPosMaxAbsY_inTemplate=NAN;

        std::vector<double> templatePositionsX_flat;
        std::vector<double> templatePositionsY_flat;
        std::vector<double> templatePositionsZ_flat;
        std::vector<std::size_t> templateIndexIntoFlatList(templatePositionsZ.size());

        for (std::size_t i=0;i<templatePositionsX.size();++i)
        {
            templateIndexIntoFlatList[i] = templatePositionsX_flat.size();
            for (std::size_t j=0;j<templatePositionsX[i].size();++j)
            {
                templatePositionsX_flat.push_back(templatePositionsX[i][j]);
                templatePositionsY_flat.push_back(templatePositionsY[i][j]);
                templatePositionsZ_flat.push_back(templatePositionsZ[i][j]);

                double absX = std::abs(templatePositionsX[i][j]);
                double absY = std::abs(templatePositionsY[i][j]);

                if ((absX > geoDomPosMaxAbsX_inTemplate) || std::isnan(geoDomPosMaxAbsX_inTemplate)) geoDomPosMaxAbsX_inTemplate=absX;
                if ((absY > geoDomPosMaxAbsY_inTemplate) || std::isnan(geoDomPosMaxAbsY_inTemplate)) geoDomPosMaxAbsY_inTemplate=absY;
            }
        }
        
        
        
        log_debug("There are %zu string templates for %zu strings", templatePositionsX.size(), strings.size());
        
        std::vector<cl_float> domPosBuffer;
        
        domPosBuffer.assign(strings.size()*maxNumDoms*4, NAN);
        
        for (std::size_t i=0;i<strings.size();++i)
        {
            for (unsigned long j=0;j<strings[i].doms.size();++j)
            {
                const domStruct &currentDomStruct = strings[i].doms[j];
                
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 0] = currentDomStruct.posX;
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 1] = currentDomStruct.posY;
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 2] = currentDomStruct.posZ;
                domPosBuffer[i*(maxNumDoms*4)+j*4 + 3] = NAN;
                
                //std::cout << "string=" << i << " dom=" << j << ": pos=(" << currentDomStruct.posX << "," << currentDomStruct.posY << "," << currentDomStruct.posZ << ")" << std::endl;
                
            }
        }

        const bool useShortsInsteadOfFloats=true;
        
        /// new method: prepare output buffer
        std::ostringstream output(std::ostringstream::out);
        // write the output buffer
        output << "// this is auto-generated code created by generate_get_dom_position_code()" << std::endl;
        output << std::endl;
        output.setf(std::ios::scientific,std::ios::floatfield);
        output.precision(std::numeric_limits<float>::digits10+4); // maximum precision for a float

        output << "#define GEO_MAX_DOM_INDEX " << maxNumDoms << std::endl;
        
        if (useShortsInsteadOfFloats) {
            output << "#define GEO_DOM_POS_MAX_ABS_X_MULTIPLIER_IN_TEMPLATE " << geoDomPosMaxAbsX_inTemplate/32767. << "f" << std::endl;
            output << "#define GEO_DOM_POS_MAX_ABS_Y_MULTIPLIER_IN_TEMPLATE " << geoDomPosMaxAbsY_inTemplate/32767. << "f" << std::endl;
            output << std::endl;
            
            double xPrecision = geoDomPosMaxAbsX_inTemplate/32767.;
            double yPrecision = geoDomPosMaxAbsY_inTemplate/32767.;
            
            log_info(" -> using 2 bytes for deltaX storage vs. string mean X. => precision=%fmm", xPrecision/I3Units::mm);
            log_info(" -> using 2 bytes for deltaY storage vs. string mean Y. => precision=%fmm", yPrecision/I3Units::mm);
        } else {
            log_info(" -> using 4 byte floats for deltaX and deltaY vs. string mean (x,y)-pos");
        }

        const std::string typeString = useShortsInsteadOfFloats?"short":"float";
        
        output << "#define GEO_DOM_POS_NUM_FLAT_LIST_ENTRIES " << templatePositionsX_flat.size() << std::endl;
        output << "__constant " << typeString << " geoDomPosTemplatePositionsX_flat[GEO_DOM_POS_NUM_FLAT_LIST_ENTRIES] = {" << std::endl;
        for (std::size_t i=0;i<templatePositionsX_flat.size();++i){
            if (useShortsInsteadOfFloats) {
                const short value = static_cast<short>(templatePositionsX_flat[i]/(geoDomPosMaxAbsX_inTemplate/32767.));
                output << "  " << value << "," << std::endl;
            } else {
                output << "  " << templatePositionsX_flat[i] << "f," << std::endl;
            }
        }
        output << "};" << std::endl;
        output << "__constant " << typeString << " geoDomPosTemplatePositionsY_flat[GEO_DOM_POS_NUM_FLAT_LIST_ENTRIES] = {" << std::endl;
        for (std::size_t i=0;i<templatePositionsY_flat.size();++i){     
            if (useShortsInsteadOfFloats) {
                const short value = static_cast<short>(templatePositionsY_flat[i]/(geoDomPosMaxAbsY_inTemplate/32767.));
                output << "  " << value << "," << std::endl;
            } else {
                output << "  " << templatePositionsY_flat[i] << "f," << std::endl;
            }
        }
        output << "};" << std::endl;

        output << "__constant float geoDomPosTemplatePositionsZ_flat[GEO_DOM_POS_NUM_FLAT_LIST_ENTRIES] = {" << std::endl;
        for (std::size_t i=0;i<templatePositionsZ_flat.size();++i){     
            output << "  " << templatePositionsZ_flat[i] << "f," << std::endl;
        }
        output << "};" << std::endl;
        
        output << "#define GEO_DOM_POS_NUM_STRINGS " << strings.size() << std::endl;
        output << "__constant unsigned int geoDomPosStringStartIndexInTemplateDomList[GEO_DOM_POS_NUM_STRINGS] = {" << std::endl;
        for (std::size_t i=0;i<stringInTemplate.size();++i){     
            output << "  " << templateIndexIntoFlatList[stringInTemplate[i]] << "," << std::endl;
        }
        output << "};" << std::endl;

        output << "__constant float geoDomPosStringMeanPosX[GEO_DOM_POS_NUM_STRINGS] = {" << std::endl;
        for (std::size_t i=0;i<stringMeanPosX.size();++i){     
            output << "  " << stringMeanPosX[i] << "f," << std::endl;
        }
        output << "};" << std::endl;

        output << "__constant float geoDomPosStringMeanPosY[GEO_DOM_POS_NUM_STRINGS] = {" << std::endl;
        for (std::size_t i=0;i<stringMeanPosY.size();++i){     
            output << "  " << stringMeanPosY[i] << "f," << std::endl;
        }
        output << "};" << std::endl;

        
        output << "inline void geometryGetDomPosition(unsigned short stringNum, unsigned short domNum, floating_t *domPosX, floating_t *domPosY, floating_t *domPosZ);" << std::endl;
        output << "inline void geometryGetDomPosition(unsigned short stringNum, unsigned short domNum, floating_t *domPosX, floating_t *domPosY, floating_t *domPosZ)" << std::endl;
        output << "{" << std::endl;
        
        output << "    const unsigned int index = geoDomPosStringStartIndexInTemplateDomList[stringNum]+convert_uint(domNum);" << std::endl;

        if (useShortsInsteadOfFloats) {
            output << "    *domPosX = convert_floating_t(geoDomPosTemplatePositionsX_flat[index])*GEO_DOM_POS_MAX_ABS_X_MULTIPLIER_IN_TEMPLATE + geoDomPosStringMeanPosX[stringNum];" << std::endl;
            output << "    *domPosY = convert_floating_t(geoDomPosTemplatePositionsY_flat[index])*GEO_DOM_POS_MAX_ABS_Y_MULTIPLIER_IN_TEMPLATE + geoDomPosStringMeanPosY[stringNum];" << std::endl;
            output << "    *domPosZ = geoDomPosTemplatePositionsZ_flat[index];" << std::endl;
        } else {
            output << "    *domPosX = geoDomPosTemplatePositionsX_flat[index] + geoDomPosStringMeanPosX[stringNum];" << std::endl;
            output << "    *domPosY = geoDomPosTemplatePositionsY_flat[index] + geoDomPosStringMeanPosY[stringNum];" << std::endl;
            output << "    *domPosZ = geoDomPosTemplatePositionsZ_flat[index];" << std::endl;
        }
        output << "}" << std::endl;
        output << std::endl;
        
        
        
        output << "// end of auto-generated code created by generate_get_dom_position_code()" << std::endl;
        output << std::endl;
        return output.str();

    }
    
    
    bool write_geometry_code_and_fill_buffer(std::string &code, 
                                             const std::vector<int> &stringIDs,
                                             const std::vector<unsigned int> &domIDs,
                                             const std::vector<double> &posX,
                                             const std::vector<double> &posY,
                                             const std::vector<double> &posZ,
                                             const std::vector<std::string> &subdetectors,
                                             const double omRadius,
                                             std::vector<cl_ushort> &geoLayerToOMNumIndexPerStringSetBuffer,
                                             std::vector<int> &stringIndexToStringIDBuffer,
                                             std::vector<std::vector<unsigned int> > &domIndexToDomIDBuffer_perStringIndex
                                             )
    {
        typedef std::vector<int>::size_type sizeType;
        
        sizeType numEntries=stringIDs.size();
        if (numEntries==0) {std::cerr << "Empty geometry provided." << std::endl; return false;}
        if ((domIDs.size() != numEntries) ||
            (posX.size() != numEntries) ||
            (posY.size() != numEntries) ||
            (posZ.size() != numEntries) ||
            (subdetectors.size() != numEntries))
            return false;
        if (omRadius < 0.) {std::cerr << "Zero or negative OM radius." << std::endl; return false;}
        
        typedef std::pair<int, std::string> intStringPair_t;
        std::set<intStringPair_t> stringIDSet;
        std::set<std::string> subdetectorSet;
        for (sizeType i=0; i<numEntries; ++i)
        {
            stringIDSet.insert(std::make_pair(stringIDs[i], subdetectors[i]));
            subdetectorSet.insert(subdetectors[i]);
        }
        
        #define MAX_SUPPORTED_NUM_STRINGS 0xFFFF-1
        if (stringIDSet.size() >= MAX_SUPPORTED_NUM_STRINGS) {
            std::cerr << "More than " << MAX_SUPPORTED_NUM_STRINGS << " strings are not supported." << std::endl;
            return false;
        }

        #define MAX_SUPPORTED_NUM_SUBDETECTORS 0xFFFF-1
        if (subdetectorSet.size() >= MAX_SUPPORTED_NUM_SUBDETECTORS) {
            std::cerr << "More than " << MAX_SUPPORTED_NUM_SUBDETECTORS << " subdetectors are not supported." << std::endl;
            return false;
        }
        log_trace("Number of subdetectors is %zu:", subdetectorSet.size());

        const unsigned short numSubdetectors = static_cast<unsigned short>(subdetectorSet.size());
        
        std::map<std::string, unsigned short> subdetectorNameToIDMap;
        std::vector<std::string> subdetectorNameList;
        {
            unsigned short currentIndex=0;
            BOOST_FOREACH(const std::string &subdetectorName, subdetectorSet)
            {
                log_trace(" #%us -> \"%s\"", currentIndex, subdetectorName.c_str());

                subdetectorNameToIDMap.insert(std::make_pair(subdetectorName, currentIndex));
                subdetectorNameList.push_back(subdetectorName);
                ++currentIndex;
            }
        }
        
        // build string structure
        std::vector<stringStruct> strings(stringIDSet.size());
        unsigned int stringIndex=0;
        double stringMaxR=NAN;
        BOOST_FOREACH(const intStringPair_t &pairRef, stringIDSet)
        {
            const int stringID = pairRef.first;
            const std::string &subdetectorName = pairRef.second;
            
            stringStruct &currentStringStruct = strings[stringIndex];
            
            currentStringStruct.stringID = stringID;
            currentStringStruct.maxZ=NAN;
            currentStringStruct.minZ=NAN;
            currentStringStruct.meanX=0.;
            currentStringStruct.meanY=0.;
            currentStringStruct.maxR=NAN;
            currentStringStruct.subdetectorNum = subdetectorNameToIDMap[subdetectorName];
            currentStringStruct.doms.clear();
            
            // loop over all doms. only use them if they are on the current string
            unsigned long numDoms=0;
            double lastZ=NAN;
            double lastdZ=NAN;
            unsigned int numdZ = 0;
            double meandZ = 0.;
            for (unsigned long i=0;i<numEntries;++i)
            {
                if (stringIDs[i] != stringID) continue;
                // index i is on the current string!
                
                if (subdetectors[i] != subdetectorName) continue;
                
                currentStringStruct.meanX += posX[i];
                currentStringStruct.meanY += posY[i];
                if ((posZ[i] > currentStringStruct.maxZ) || std::isnan(currentStringStruct.maxZ))
                    currentStringStruct.maxZ = posZ[i];
                if ((posZ[i] < currentStringStruct.minZ) || std::isnan(currentStringStruct.minZ))
                    currentStringStruct.minZ = posZ[i];
                
                if (std::isnan(lastZ)) {
                    lastZ = posZ[i];
                } else {
                    double dZ = std::abs(lastZ-posZ[i]);
                    lastZ = posZ[i];
                    if (!std::isnan(lastdZ)) {
                        if (dZ < 1.75*meandZ/static_cast<double>(numdZ)) {
                            // consider spacings greater than 75% of the current mean as invalid (missing DOM on string)
                            meandZ += dZ;
                            numdZ++;
                            
                            lastdZ = dZ;
                        }
                    } else {
                        lastdZ = dZ;
                        meandZ += dZ;
                        numdZ++;
                    }
                }
                
                // insert this dom
                currentStringStruct.doms.push_back(domStruct());
                domStruct &currentDomStruct = currentStringStruct.doms.back();
                
                currentDomStruct.domID = domIDs[i];
                currentDomStruct.posX = posX[i];
                currentDomStruct.posY = posY[i];
                currentDomStruct.posZ = posZ[i];
                
                ++numDoms;
            }
            currentStringStruct.meanX /= static_cast<double>(numDoms);
            currentStringStruct.meanY /= static_cast<double>(numDoms);
            meandZ /= static_cast<double>(numdZ);
            currentStringStruct.meandZ = meandZ;
            
            log_trace("String %u has minZ=%f, maxZ=%f, numDoms=%lu, meandZ=%f",
                      stringIndex, currentStringStruct.minZ, currentStringStruct.maxZ,
                      numDoms, currentStringStruct.meandZ);

            // calculate the string radius (will be the OM radius for a straight string)
            for (unsigned long i=0;i<numEntries;++i)
            {
                if (stringIDs[i]!=stringID) continue;
                // index i is on the current string!
                
                if (subdetectors[i] != subdetectorName) continue;

                const double dX = currentStringStruct.meanX - posX[i];
                const double dY = currentStringStruct.meanY - posY[i];
                const double thisR = std::sqrt(dX*dX + dY*dY)+omRadius;
                
                if ((thisR > currentStringStruct.maxR) || std::isnan(currentStringStruct.maxR))
                    currentStringStruct.maxR = thisR;
                
                if ((thisR > stringMaxR) || std::isnan(stringMaxR))
                    stringMaxR = thisR;
            }
            
            log_trace("String %u has radius %f",
                      stringIndex, currentStringStruct.maxR);
            
            
            log_trace("string #%u (id %i) on subdetector %u (\"%s\") has %zu DOMs",
                      stringIndex, stringID, currentStringStruct.subdetectorNum, subdetectorName.c_str(), currentStringStruct.doms.size());

            ++stringIndex;
        }
        
        log_trace("Number of strings is %zu", strings.size());
        
        if (false) {
            // dump strings
            for (std::size_t stringNum=0;stringNum<strings.size();++stringNum)
            {
                for (std::size_t domNum=0;domNum<strings[stringNum].doms.size();++domNum)
                {
                    log_warn("geo_add stringIndex=%2zu, domIndex=%2zu  stringNumber=%2i domNumber%2u  pos=(%f,%f,%f)",
                             stringNum, domNum, strings[stringNum].stringID, strings[stringNum].doms[domNum].domID,
                             strings[stringNum].doms[domNum].posX,
                             strings[stringNum].doms[domNum].posY,
                             strings[stringNum].doms[domNum].posZ
                             );
                    
                }
                
            }
        }
        
        
        std::vector<unsigned short> cellGridNumX(numSubdetectors, 1);
        std::vector<unsigned short> cellGridNumY(numSubdetectors, 1);
        std::vector<std::vector<unsigned short> > cellToStringIndex(numSubdetectors, std::vector<unsigned short>());
        std::vector<double> cellStartX(numSubdetectors, NAN);
        std::vector<double> cellStartY(numSubdetectors, NAN);
        std::vector<double> cellWidthX(numSubdetectors, NAN);
        std::vector<double> cellWidthY(numSubdetectors, NAN);

        for (unsigned short subdetectorNum=0;subdetectorNum<numSubdetectors;++subdetectorNum)
        {
            // Try to split the detector into xy "cells" with 0 or 1 strings per cell.
            // We do not need to optimize this, so we use a brute force approach:
            // start with only one cell and subdivide it until the requirement 
            // max(Nstringpercell)==1 is fulfilled.
            cellGridNumX[subdetectorNum]=1;
            cellGridNumY[subdetectorNum]=1;
            cellToStringIndex[subdetectorNum].clear();

            for(;;)
            {
                bool divisionIsPossible = divideIntoCells(strings,
                                                          static_cast<int>(subdetectorNum),
                                                          cellStartX[subdetectorNum],
                                                          cellStartY[subdetectorNum],
                                                          cellWidthX[subdetectorNum],
                                                          cellWidthY[subdetectorNum],
                                                          cellGridNumX[subdetectorNum],
                                                          cellGridNumY[subdetectorNum],
                                                          cellToStringIndex[subdetectorNum]);
                
                if (divisionIsPossible) break;
                ++cellGridNumX[subdetectorNum];
                ++cellGridNumY[subdetectorNum];
                
                if (cellGridNumX[subdetectorNum] >= 1000) {
                    log_fatal("Could not generate a x-y cell division for your subdetector \"%s\".",
                              subdetectorNameList[subdetectorNum].c_str());
                }
            }
            
            log_info("subdetector #%u (\"%s\"):", subdetectorNum, subdetectorNameList[subdetectorNum].c_str());
            log_info("Geometry cell division: %ux%u", cellGridNumX[subdetectorNum], cellGridNumY[subdetectorNum]);
            log_info("from x=%fm, width=%fm", cellStartX[subdetectorNum], cellWidthX[subdetectorNum]);
            log_info("from y=%fm, width=%fm", cellStartY[subdetectorNum], cellWidthY[subdetectorNum]);
        }
        
        
        // try to split the detector into z "layers" with either a single dom number in it or
        // no dom number at all. We restrict ourselves to a detector where dom z-positions are
        // correlated to their numbers.
        
        unsigned int numStringSets=0;
        std::vector<unsigned int> geoLayerNum;
        std::vector<double> layerStartZ, layerHeight;
        
        std::vector<std::vector<unsigned short> > layerToOMNumIndexPerStringSet;
        std::vector<unsigned char> stringInStringSet(strings.size()); 
        
        double minZHint, maxZHint;
        findOverallStringMinMaxZ(strings, omRadius, minZHint, maxZHint, false);
        
        log_trace("overall minZ=%fm, maxZ=%fm", minZHint, maxZHint);

        unsigned int maxLayerNum=0;
        for (unsigned int stringNum=0;stringNum<strings.size();++stringNum)
        {
            //std::cout << "checking string " << stringNum << std::endl;
            // first check if the current string matches one of the previous layer division
            
            bool matchFound=false; unsigned int existingStringSetNum;
            for (unsigned int stringSetNum=0;stringSetNum<numStringSets;++stringSetNum)
            {
                //std::cout << "  cheking if it matches layering " << stringSetNum << std::endl;
                
                bool ret = doesMatchLayering(strings[stringNum],
                                             layerStartZ[stringSetNum],
                                             layerHeight[stringSetNum],
                                             geoLayerNum[stringSetNum],
                                             omRadius,
                                             layerToOMNumIndexPerStringSet[stringSetNum]);
                if (ret) {existingStringSetNum=stringSetNum;matchFound=true; break;}
            }
            if (matchFound)
            {
                //std::cout << "  YES! matches layering " << existingStringSetNum << std::endl;
                
                // not much work to be done here
                stringInStringSet[stringNum] = existingStringSetNum;
            }
            else
            {
                stringInStringSet[stringNum] = numStringSets;
                //std::cout << "  NO -> creating new layering " << numStringSets << std::endl;
                
                // need to create a new layering for this string
                ++numStringSets;
                if (numStringSets >= 0xFF) {
                    log_fatal("Not more than 255 different string layer divisions (\"string sets\") are supported!");
                }
                
                layerStartZ.push_back(NAN);
                layerHeight.push_back(NAN);
                geoLayerNum.push_back(1);
                layerToOMNumIndexPerStringSet.push_back(std::vector<unsigned short>());

                geoLayerNum.back() = static_cast<unsigned int>((strings[stringNum].maxZ-strings[stringNum].minZ+strings[stringNum].meandZ)/strings[stringNum].meandZ);
                bool divisionIsPossible = divideIntoLayers(strings[stringNum],
                                                           layerStartZ.back(),
                                                           layerHeight.back(),
                                                           geoLayerNum.back(),
                                                           omRadius,
                                                           strings[stringNum].minZ-strings[stringNum].meandZ/2.,
                                                           strings[stringNum].maxZ+strings[stringNum].meandZ/2.,
                                                           layerToOMNumIndexPerStringSet.back());

                if (!divisionIsPossible)
                {
                    log_debug("simple division is not possible for string %u. tried %u layers", stringNum, geoLayerNum.back());

                    geoLayerNum.back() = static_cast<unsigned int>((strings[stringNum].maxZ-strings[stringNum].minZ+strings[stringNum].meandZ)/strings[stringNum].meandZ)+1;
                    divisionIsPossible = divideIntoLayers(strings[stringNum],
                                                          layerStartZ.back(),
                                                          layerHeight.back(),
                                                          geoLayerNum.back(),
                                                          omRadius,
                                                          strings[stringNum].minZ-strings[stringNum].meandZ/2.,
                                                          strings[stringNum].maxZ+strings[stringNum].meandZ/2.,
                                                          layerToOMNumIndexPerStringSet.back());
                    
                    if (divisionIsPossible)
                        log_debug(" -> but it is possible with %u layers!", geoLayerNum.back());
                        
                }
                
                if (!divisionIsPossible)
                {
                    log_debug("simple division is not possible for string %u. tried %u layers", stringNum, geoLayerNum.back());

                    geoLayerNum.back()=1;
                    for(;;)
                    {
                        divisionIsPossible = divideIntoLayers(strings[stringNum],
                                                              layerStartZ.back(),
                                                              layerHeight.back(),
                                                              geoLayerNum.back(),
                                                              omRadius,
                                                              strings[stringNum].minZ-strings[stringNum].meandZ/2.,
                                                              strings[stringNum].maxZ+strings[stringNum].meandZ/2.,
                                                              layerToOMNumIndexPerStringSet.back());
                        if (divisionIsPossible) break;
                        ++geoLayerNum.back();
                        
                        if (geoLayerNum.back() >= 1000) {
                            
                            std::size_t counter=0;
                            BOOST_FOREACH(const domStruct &currentDomStruct, strings[stringNum].doms)
                            {
                                log_error("DOM #%zu (id %u) @ pos=(%f,%f,%f)",
                                          counter,
                                          currentDomStruct.domID, 
                                          currentDomStruct.posX,
                                          currentDomStruct.posY,
                                          currentDomStruct.posZ);
                                ++counter;
                            }
                            
                            log_fatal("There does not seem to be a possible layer division for your string %i on subdetector %i (\"%s\"). minZ=%fm, maxZ=%fm, meandZ=%fm, omRadius=%fm",
                                      stringNum, strings[stringNum].subdetectorNum, subdetectorNameList[strings[stringNum].subdetectorNum].c_str(),
                                      strings[stringNum].minZ/I3Units::m, strings[stringNum].maxZ/I3Units::m, strings[stringNum].meandZ/I3Units::m, omRadius/I3Units::m);
                        }
                    }
                }
                
                if (geoLayerNum.back()>maxLayerNum) maxLayerNum=geoLayerNum.back();
                
            } // end if (matchfound)
            
        } // for (stringNum)
        
        std::vector<unsigned short> geoLayerToOMNumIndex(maxLayerNum*numStringSets, 0xFFFF);
        for (unsigned int j=0;j<numStringSets;++j)
        {
            for (unsigned int i=0;i<geoLayerNum[j];++i)
            {
                geoLayerToOMNumIndex[j*maxLayerNum+i] = layerToOMNumIndexPerStringSet[j][i];
            }
        }
        
        log_info("There are %u string sets:", numStringSets);
        for (unsigned int stringSetNum=0;stringSetNum<numStringSets;++stringSetNum)
        {
            log_info(" * Set %u:", stringSetNum);
            log_info("   Geometry layer division: %u layers", geoLayerNum[stringSetNum]);
            log_info("   from z=%fm, height=%fm",
                     layerStartZ[stringSetNum],
                     layerHeight[stringSetNum]);
        }
        
        
        unsigned int geoLayerToOMNumIndexPerStringSetBuffer_size = ((numStringSets*maxLayerNum)/64)+1;
        geoLayerToOMNumIndexPerStringSetBuffer_size *= 64;
        log_debug("BSize: %u -> %u", numStringSets*maxLayerNum, geoLayerToOMNumIndexPerStringSetBuffer_size);
        
        geoLayerToOMNumIndexPerStringSetBuffer.assign(geoLayerToOMNumIndexPerStringSetBuffer_size,0xFFFF);
        for (unsigned int i=0;i<numStringSets*maxLayerNum;++i)
        {
            geoLayerToOMNumIndexPerStringSetBuffer[i] = geoLayerToOMNumIndex[i];
        }
        
        // initialize the stringIndex to stringID buffer
        stringIndexToStringIDBuffer.resize(strings.size());
        for (std::size_t i=0;i<strings.size();++i)
        {
            stringIndexToStringIDBuffer[i] = strings[i].stringID;
        }

        // initialize the DOMIndex to OMID buffer
        domIndexToDomIDBuffer_perStringIndex.resize(strings.size());
        for (std::size_t i=0;i<strings.size();++i)
        {
            std::vector<unsigned int> &domIndexToDomIDBuffer = domIndexToDomIDBuffer_perStringIndex[i];
            domIndexToDomIDBuffer.resize(strings[i].doms.size());

            for (std::size_t j=0;j<strings[i].doms.size();++j)
            {
                domIndexToDomIDBuffer[j] = strings[i].doms[j].domID;
            }
        }

        // string information goes to the constant memory
        
        // prepare the output buffer
        std::ostringstream output(std::ostringstream::out);
        
        // write the output buffer
        output << "// this is auto-generated code created by write_geometry_code_and_fill_buffer()" << std::endl;
        output << std::endl;
        
        
        output.setf(std::ios::scientific,std::ios::floatfield);
        output.precision(std::numeric_limits<float>::digits10+4); // maximum precision for a float
        

        // the dom position lookup code (i.e. (stringNum,domNum)->(posX, posY, posZ) )
        output << generate_get_dom_position_code(strings);
        
        
        // all the other data
        output << "#define NUM_STRINGS " << strings.size() << std::endl;
        output << "#define OM_RADIUS " << omRadius << "f" << std::endl;
        
        output << "#define GEO_LAYER_STRINGSET_NUM " << numStringSets << std::endl;
        output << "#define GEO_LAYER_STRINGSET_MAX_NUM_LAYERS " << maxLayerNum << std::endl;
        
        output << std::endl;
        
        //output << "__constant const short geoStringIDs[NUM_STRINGS] = {" << std::endl;
        //for (sizeType j=0;j<strings.size();++j){     
        //  output << "  " << strings[j].stringID << ", " << std::endl;
        //}
        //output << "};" << std::endl;
        //output << std::endl;
        
        //output << "__constant unsigned short geoStringNumDoms[NUM_STRINGS] = {" << std::endl;
        //for (sizeType j=0;j<strings.size();++j){     
        //    output << "  " << strings[j].doms.size() << ", " << std::endl;
        //}
        //output << "};" << std::endl;
        //output << std::endl;
        
        output << "__constant float geoStringPosX[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<strings.size();++j){     
            output << "  " << strings[j].meanX << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "__constant float geoStringPosY[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<strings.size();++j){     
            output << "  " << strings[j].meanY << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "#define GEO_STRING_MAX_RADIUS " << stringMaxR << "f" << std::endl;
        output << "__constant float geoStringRadius[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<strings.size();++j){     
            output << "  " << strings[j].maxR << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "__constant float geoStringMinZ[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<strings.size();++j){     
            output << "  " << strings[j].minZ << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;
        
        output << "__constant float geoStringMaxZ[NUM_STRINGS] = {" << std::endl;
        for (sizeType j=0;j<strings.size();++j){     
            output << "  " << strings[j].maxZ << "f, " << std::endl;
        }
        output << "};" << std::endl;
        output << std::endl;

        
        output << "#define GEO_CELL_NUM_SUBDETECTORS " << numSubdetectors << std::endl;
        for (unsigned short subdetectorNum=0;subdetectorNum<numSubdetectors;++subdetectorNum)
        {
            std::string subdetectorNumStringSuffix = "_" + boost::lexical_cast<std::string>(subdetectorNum);
            
            output << "#define GEO_CELL_NUM_X" << subdetectorNumStringSuffix << " " << cellGridNumX[subdetectorNum] << std::endl;
            output << "#define GEO_CELL_NUM_Y" << subdetectorNumStringSuffix << " " << cellGridNumY[subdetectorNum] << std::endl;
            output << "#define GEO_CELL_WIDTH_X" << subdetectorNumStringSuffix << " " << cellWidthX[subdetectorNum] << "f" << std::endl;
            output << "#define GEO_CELL_WIDTH_Y" << subdetectorNumStringSuffix << " " << cellWidthY[subdetectorNum] << "f" << std::endl;
            output << "#define GEO_CELL_START_X" << subdetectorNumStringSuffix << " " << cellStartX[subdetectorNum] << "f" << std::endl;
            output << "#define GEO_CELL_START_Y" << subdetectorNumStringSuffix << " " << cellStartY[subdetectorNum] << "f" << std::endl;

            output << "__constant unsigned short geoCellIndex" << subdetectorNumStringSuffix << "[GEO_CELL_NUM_X" << subdetectorNumStringSuffix << "*GEO_CELL_NUM_Y" << subdetectorNumStringSuffix << "] = {" << std::endl;
            for (sizeType j=0;j<cellGridNumY[subdetectorNum];++j){
                for (sizeType i=0;i<cellGridNumX[subdetectorNum];++i){     
                    const std::vector<unsigned short> &this_cellToStringIndex = cellToStringIndex[subdetectorNum];
                    const unsigned short value = this_cellToStringIndex[j*cellGridNumX[subdetectorNum]+i];
                    
                    if (value == 0xFFFF) {
                        output << "  " << "0xFFFF" << ", " << std::endl;
                    } else {
                        output << "  " << value << ", " << std::endl;
                    }
                }
            }
            output << "};" << std::endl;
            output << std::endl;
        }        
        
        output << "__constant unsigned char geoStringInStringSet[NUM_STRINGS] = {" << std::endl;
        for (unsigned int i=0;i<strings.size();++i)
        {
            output << "  " << (int)stringInStringSet[i] << ", " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "__constant unsigned short geoLayerNum[GEO_LAYER_STRINGSET_NUM] = {" << std::endl;
        for (unsigned int i=0;i<numStringSets;++i)
        {
            output << "  " << geoLayerNum[i] << ", " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "__constant float geoLayerStartZ[GEO_LAYER_STRINGSET_NUM] = {" << std::endl;
        for (unsigned int i=0;i<numStringSets;++i)
        {
            output << "  " << layerStartZ[i] << "f, " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "__constant float geoLayerHeight[GEO_LAYER_STRINGSET_NUM] = {" << std::endl;
        for (unsigned int i=0;i<numStringSets;++i)
        {
            output << "  " << layerHeight[i] << "f, " << std::endl;
        }
        output << "};" << std::endl;
        
        output << "#define GEO_geoLayerToOMNumIndexPerStringSet_BUFFER_SIZE " << geoLayerToOMNumIndexPerStringSetBuffer_size << std::endl;
        
        // return the code we just wrote to the caller
        code = output.str();
        
        return true;
    }
    
    

};
